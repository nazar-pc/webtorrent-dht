// Generated by LiveScript 1.5.0
/**
 * @package   WebTorrent DHT
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var bencode, debug, inherits, isIP, kRpcSocket, webrtcSocket, noop, K, x$, slice$ = [].slice;
  bencode = require('bencode');
  debug = require('debug')('webtorrent-dht');
  inherits = require('inherits');
  isIP = require('isipaddress').test;
  kRpcSocket = require('k-rpc-socket');
  webrtcSocket = require('./webrtc-socket');
  module.exports = kRpcSocketWebrtc;
  noop = function(){};
  K = 20;
  function parse_nodes(buffer){
    var nodes, res$, i$, to$, i;
    res$ = [];
    for (i$ = 0, to$ = buffer.length; i$ < to$; i$ += 26) {
      i = i$;
      res$.push(parse_node(buffer.slice(i, i + 26)));
    }
    nodes = res$;
    return nodes.filter(Boolean);
  }
  function parse_node(buffer){
    var id, ref$, host, port;
    id = buffer.slice(0, 20);
    ref$ = parse_info(buffer.slice(20, 26)), host = ref$.host, port = ref$.port;
    return {
      id: id,
      host: host,
      port: port
    };
  }
  function parse_info(buffer){
    var host, port;
    host = buffer[0] + '.' + buffer[1] + '.' + buffer[2] + '.' + buffer[3];
    port = buffer.readUInt16BE(4);
    return {
      host: host,
      port: port
    };
  }
  function encode_node(id, ip, port){
    var info;
    id = Buffer.from(id);
    info = encode_info(ip, port);
    return Buffer.concat([id, info], 26);
  }
  function encode_info(ip, port){
    var x$;
    ip = Buffer.from(ip.split('.').map(function(octet){
      return parseInt(octet, 10);
    }));
    port = (x$ = Buffer.alloc(2), x$.writeUInt16BE(port), x$);
    return Buffer.concat([ip, port], 6);
  }
  /**
   * k-rpc-socket modified to work with WebRTC
   */
  function kRpcSocketWebrtc(options){
    options == null && (options = {});
    if (!(this instanceof kRpcSocketWebrtc)) {
      return new kRpcSocketWebrtc(options);
    }
    this.k = options.k || K;
    if (!options.id) {
      throw new Error('k-rpc-socket-webrtc requires options.id to be specified explicitly');
    }
    if (Buffer.isBuffer(options.id)) {
      this.id = options.id;
    } else {
      this.id = Buffer.from(options.id, 'hex');
    }
    options.socket = options.socket || webrtcSocket(options);
    options.isIP = isIP;
    kRpcSocket.call(this, options);
  }
  /**
   * Multi-level inheritance: k-rpc-socket-webrtc inherits from noop (which will contain additional methods) and noop inherits from k-rpc-socket
   */
  inherits(noop, kRpcSocket);
  inherits(kRpcSocketWebrtc, noop);
  x$ = kRpcSocketWebrtc.prototype;
  x$.send = function(peer, message, callback){
    debug('send to peer: %o', arguments);
    kRpcSocket.prototype.send.call(this, peer, message, callback);
  };
  x$.response = function(peer, query, response, callback){
    var signals, peers, this$ = this;
    debug('response: %o', arguments);
    response = Object.assign({}, response);
    switch (query.q.toString()) {
    case 'find_node':
    case 'get_peers':
    case 'get':
      /**
       * Before sending response we'll send signaling data to selected nodes and will pass signaling data back to querying node so that it can then
       * establish connection if needed
       */
      signals = query.a.signals;
      if (!Array.isArray(signals)) {
        return;
      }
      if (response.nodes) {
        if (response.nodes.length / 26 > signals.length) {
          response.nodes.length = signals.length * 26;
        }
        peers = parse_nodes(response.nodes);
      } else if (response.values) {
        if (response.values.length > signals.length) {
          response.values.length = signals.length;
        }
        peers = response.values.map(parse_info);
      } else {
        kRpcSocket.prototype.response.call(this, peer, query, response, callback);
        break;
      }
      Promise.all((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = peers).length; i$ < len$; ++i$) {
          results$.push((fn$.call(this, i$, ref$[i$])));
        }
        return results$;
        function fn$(i, peer){
          var this$ = this;
          return new Promise(function(resolve){
            kRpcSocket.prototype.query.call(this$, peer, {
              q: 'peer_connection',
              a: {
                id: this$.id,
                signal: signals[i]
              }
            }, function(error, response){
              resolve({
                error: error,
                response: response
              });
            });
          });
        }
      }.call(this))).then(function(replies){
        var res$, i$, to$, i, ref$;
        res$ = [];
        for (i$ = 0, to$ = peers.length; i$ < to$; ++i$) {
          i = i$;
          if (replies[i].error) {
            res$.push(null);
          } else {
            res$.push(((ref$ = replies[i].response.r) != null ? ref$.signal : void 8) || null);
          }
        }
        response.signals = res$;
        kRpcSocket.prototype.response.call(this$, peer, query, response, callback);
      });
      break;
    default:
      kRpcSocket.prototype.response.call(this, peer, query, response, callback);
    }
  };
  x$.query = function(peer, query, callback){
    var i, this$ = this;
    debug('query: %o', arguments);
    query = Object.assign({}, query);
    switch (query.q.toString()) {
    case 'find_node':
    case 'get_peers':
    case 'get':
      Promise.all((function(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = this.k; i$ < to$; ++i$) {
          i = i$;
          results$.push(new Promise(fn$));
        }
        return results$;
        function fn$(resolve){
          var x$, peer_connection;
          x$ = peer_connection = this$.socket.prepare_connection(true);
          x$.on('signal', function(signal){
            resolve({
              peer_connection: peer_connection,
              signal: signal
            });
          });
          x$.on('error', function(error){
            resolve(null);
          });
        }
      }.call(this))).then(function(connections){
        var peer_connections, signals, id, i$, len$, connection;
        connections = connections.filter(Boolean);
        /**
         * Inject signal data for K connections for queried node to pass them to target nodes and get signal data from them, so that we can afterwards
         * establish direct connection to target nodes
         */
        peer_connections = [];
        signals = [];
        id = this$.id.toString('hex');
        for (i$ = 0, len$ = connections.length; i$ < len$; ++i$) {
          connection = connections[i$];
          peer_connections.push(connection.peer_connection);
          signals.push(Object.assign({
            id: id
          }, connection.signal));
        }
        query.a.signals = signals;
        kRpcSocket.prototype.query.call(this$, peer, query, function(error, response){
          var args, res$, i$, to$, host_id;
          res$ = [];
          for (i$ = 2, to$ = arguments.length; i$ < to$; ++i$) {
            res$.push(arguments[i$]);
          }
          args = res$;
          if (!(!error && Array.isArray(response.r.signals))) {
            return callback.apply(null, [error, response].concat(slice$.call(args)));
          }
          /**
           * Use signal data from response to establish connections to target nodes and re-pack nodes using address and port from
           * newly established connection rather than what queried node gave us (also not all connections might be established, so
           * nodes list might be shorter than what queried node returned)
           */
          host_id = query.a.id.toString('hex');
          Promise.all((function(){
            var i$, ref$, len$, results$ = [];
            for (i$ = 0, len$ = (ref$ = response.r.signals).length; i$ < len$; ++i$) {
              results$.push((fn$.call(this, i$, ref$[i$])));
            }
            return results$;
            function fn$(i, signal){
              var peer_connection, this$ = this;
              if (signal) {
                signal.id = signal.id.toString();
                if (signal.id === host_id) {
                  return null;
                } else {
                  peer_connection = this.socket.get_id_mapping(signal.id);
                  if (peer_connection) {
                    peer_connections[i].destroy();
                    return encode_info(peer_connection.remoteAddress, peer_connection.remotePort);
                  } else {
                    return new Promise(function(resolve){
                      var x$, peer_connection;
                      x$ = peer_connection = peer_connections[i];
                      x$.on('connect', function(){
                        this$.socket.add_id_mapping(signal.id, peer_connection);
                        if (response.r.nodes) {
                          resolve(encode_node(response.r.nodes.slice(i * 26, i * 26 + 20), peer_connection.remoteAddress, peer_connection.remotePort));
                        } else if (response.r.values) {
                          resolve(encode_info(peer_connection.remoteAddress, peer_connection.remotePort));
                        }
                      });
                      x$.on('error', function(){
                        resolve(null);
                      });
                      x$.signal(signal);
                    });
                  }
                }
              } else {
                return null;
              }
            }
          }.call(this$))).then(function(peers){
            peers = peers.filter(Boolean);
            if (response.r.nodes) {
              response.r.nodes = Buffer.concat(peers, peers.length * 26);
            } else if (response.r.values) {
              response.r.values = peers;
            }
            callback.apply(null, [error, response].concat(slice$.call(args)));
          });
        });
      });
      break;
    default:
      kRpcSocket.prototype.query.call(this, peer, query, callback);
    }
  };
  x$.emit = function(event){
    var args, res$, i$, to$, message, peer, ref$, ref1$, ref2$, id, signal, x$, peer_connection, ref3$, this$ = this;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    switch (event) {
    case 'query':
      message = args[0], peer = args[1];
      if ((ref$ = message.a) != null && ref$.id) {
        this.socket.add_id_mapping(message.a.id.toString('hex'), peer);
      }
      switch ((ref1$ = message.q) != null && (typeof ref1$.toString == 'function' && ref1$.toString())) {
      case 'peer_connection':
        if (((ref2$ = message.a) != null ? ref2$.signal : void 8) != null) {
          id = this.id.toString('hex');
          signal = message.a.signal;
          signal.id = signal.id.toString();
          if (signal.id === id || this.socket.get_id_mapping(id)) {
            this.response(peer, message, {
              id: this.id,
              signal: {
                id: id
              }
            });
          } else {
            x$ = peer_connection = this.socket.prepare_connection(false);
            x$.on('connect', function(){
              this$.socket.add_id_mapping(signal.id, peer_connection);
            });
            x$.on('signal', function(signal){
              signal.id = id;
              this$.response(peer, message, {
                id: this$.id,
                signal: signal
              });
            });
            x$.on('error', function(error){
              this$.error(peer, message, [201, error]);
            });
            x$.signal(signal);
          }
        }
        break;
      }
      break;
    case 'response':
      message = args[0], peer = args[1];
      if ((ref3$ = message.r) != null && ref3$.id) {
        this.socket.add_id_mapping(message.r.id.toString('hex'), peer);
      }
      break;
    }
    return kRpcSocket.prototype.emit.apply(this, arguments);
  };
}).call(this);
