// Generated by LiveScript 1.5.0
/**
 * @package   WebTorrent DHT
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var bencode, debug, simplePeer, wrtc, ws, PEER_CONNECTION_TIMEOUT, SIMPLE_PEER_OPTS, x$, slice$ = [].slice;
  bencode = require('bencode');
  debug = require('debug')('webtorrent-dht');
  simplePeer = require('simple-peer');
  wrtc = require('wrtc');
  ws = require('ws');
  module.exports = webrtcSocket;
  PEER_CONNECTION_TIMEOUT = 30;
  SIMPLE_PEER_OPTS = {
    trickle: false,
    wrtc: wrtc
  };
  /**
   * WebRTC socket implements a minimal subset of `dgram` interface necessary for `k-rpc-socket` while using WebRTC as transport layer instead of UDP
   */
  function webrtcSocket(options){
    options == null && (options = {});
    if (!(this instanceof webrtcSocket)) {
      return new webrtcSocket(options);
    }
    this.peer_connection_timeout = (options.peer_connection_timeout || PEER_CONNECTION_TIMEOUT) * 1000;
    this.simple_peer_opts = Object.assign({}, SIMPLE_PEER_OPTS, options.simple_peer_opts);
    this.ws_address = options.ws_address;
    this.listeners = [];
    this.peer_connections = {};
    this.ws_connections_aliases = {};
    this.pending_peer_connections = {};
    this.connections_id_mapping = {};
  }
  x$ = webrtcSocket.prototype;
  x$.address = function(){
    if (this.ws_server) {
      return this.ws_address;
    } else {
      throw new Error('WebSocket connection is not established yet');
    }
  };
  x$.bind = function(port, address, callback){
    var x$, this$ = this;
    if (!port || !address || port instanceof Function || address instanceof Function) {
      throw 'Both address and port are required for listen call';
    }
    x$ = this.ws_server = new ws.Server({
      port: port
    });
    x$.on('listening', function(){
      debug('listening for WebSocket connections on %s:%d', address, port);
      if (!this$.ws_address) {
        this$.ws_address = {
          address: address,
          port: port
        };
      }
      this$.emit('listening');
      if (typeof callback == 'function') {
        callback();
      }
    });
    x$.on('error', function(){
      this$.emit.apply(this$, ['error'].concat(slice$.call(arguments)));
    });
    x$.on('connection', function(ws_connection){
      var x$, peer_connection;
      debug('accepted WS connection');
      x$ = peer_connection = this$.prepare_connection(true);
      x$.on('signal', function(signal){
        debug('got signal for WS (server): %s', signal);
        signal = bencode.encode(signal);
        ws_connection.send(signal);
      });
      x$.on('connect', function(){
        if (ws_connection.readyState === 1) {
          ws_connection.close();
        }
      });
      ws_connection.on('message', function(data){
        var signal, e;
        try {
          signal = bencode.decode(data);
          debug('got signal message from WS (server): %s', signal);
          peer_connection.signal(signal);
        } catch (e$) {
          e = e$;
          this$.emit('error', e);
          ws_connection.close();
        }
      });
      setTimeout(function(){
        ws_connection.close();
      }, this$.peer_connection_timeout);
    });
  };
  x$.close = function(){
    var peer, ref$;
    for (peer in ref$ = this.peer_connections) {
      peer = ref$[peer];
      peer.destroy();
    }
    if (this.ws_server) {
      this.ws_server.close();
    }
  };
  x$.emit = function(eventName){
    var args, res$, i$, to$, ref$, len$, listener, results$ = [];
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    if (this.listeners[eventName]) {
      for (i$ = 0, len$ = (ref$ = this.listeners[eventName]).length; i$ < len$; ++i$) {
        listener = ref$[i$];
        results$.push(listener.apply(null, args));
      }
      return results$;
    }
  };
  x$.on = function(eventName, listener){
    var ref$;
    ((ref$ = this.listeners)[eventName] || (ref$[eventName] = [])).push(listener);
  };
  x$.send = function(buffer, offset, length, port, address, callback){
    var this$ = this;
    if (this.peer_connections[address + ":" + port]) {
      this.peer_connections[address + ":" + port].send(buffer);
      callback();
    } else if (this.ws_connections_aliases[address + ":" + port]) {
      this.ws_connections_aliases[address + ":" + port].send(buffer);
      callback();
    } else if (this.pending_peer_connections[address + ":" + port]) {
      this.pending_peer_connections[address + ":" + port].then(function(peer){
        this$.send(buffer, offset, length, port, address, callback);
      })['catch'](function(){});
    } else {
      this.pending_peer_connections[address + ":" + port] = new Promise(function(resolve, reject){
        (function(WebSocket){
          var x$, ws_connection, this$ = this;
          x$ = ws_connection = new WebSocket("ws://" + address + ":" + port);
          x$.binaryType = 'arraybuffer';
          x$.onerror = function(e){
            reject();
            this$.emit('error', e);
          };
          x$.onclose = function(){
            debug('closed WS connection');
          };
          x$.onopen = function(){
            var x$, peer_connection;
            debug('opened WS connection');
            x$ = peer_connection = this$.prepare_connection(false);
            x$.on('signal', function(signal){
              debug('got signal for WS (client): %s', signal);
              signal = bencode.encode(signal);
              ws_connection.send(signal);
            });
            x$.on('connect', function(){
              var remote_peer_info;
              if (ws_connection.readyState === 1) {
                ws_connection.close();
              }
              remote_peer_info = {
                address: peer_connection.remoteAddress,
                port: peer_connection.remotePort
              };
              this$.__register_ws_connection_alias(remote_peer_info.address, remote_peer_info.port, address, port);
              this$.send(buffer, offset, length, remote_peer_info.port, remote_peer_info.address, callback);
              resolve(remote_peer_info);
            });
            ws_connection.onmessage = function(arg$){
              var data, signal, e;
              data = arg$.data;
              try {
                signal = bencode.decode(data);
                debug('got signal message from WS (client): %s', signal);
                peer_connection.signal(signal);
              } catch (e$) {
                e = e$;
                this$.emit('error', e);
                ws_connection.close();
              }
            };
            setTimeout(function(){
              ws_connection.close();
              delete this$.pending_peer_connections[address + ":" + port];
              if (!peer_connection.connected) {
                reject();
              }
            }, this$.peer_connection_timeout);
          };
        }.call(this$, typeof WebSocket !== 'undefined' ? WebSocket : ws));
      });
      this.pending_peer_connections[address + ":" + port]['catch'](function(){});
    }
  };
  /**
   * @param {boolean} initiator
   *
   * @return {SimplePeer}
   */
  x$.prepare_connection = function(initiator){
    var x$, peer_connection, this$ = this;
    debug('prepare connection, initiator: %s', initiator);
    setTimeout(function(){
      if (!peer_connection.connected || !peer_connection.id) {
        peer_connection.destroy();
      }
    }, this.peer_connection_timeout);
    x$ = peer_connection = simplePeer(Object.assign({}, this.simple_peer_opts, {
      initiator: initiator
    }));
    x$.on('connect', function(){
      var address, data;
      debug('peer connected: %s:%d', peer_connection.remoteAddress, peer_connection.remotePort);
      this$.__register_connection(peer_connection);
      if (this$.ws_server) {
        address = this$.address();
        data = bencode.encode({
          ws_server: {
            host: address.address,
            port: address.port
          }
        });
        this$.send(Buffer.from(data), 0, data.length, peer_connection.remotePort, peer_connection.remoteAddress, function(){});
      }
      peer_connection.on('close', function(){
        debug('peer disconnected: %s:%d', peer_connection.remoteAddress, peer_connection.remotePort);
      });
    });
    x$.on('data', function(data){
      var data_decoded;
      if (debug.enabled) {
        debug('got data: %o, %s', data, data.toString());
      }
      try {
        data_decoded = bencode.decode(data);
        if (data_decoded.ws_server) {
          peer_connection.ws_server = {
            host: data_decoded.ws_server.toString(),
            port: data_decoded.ws_server.port
          };
          return;
        }
      } catch (e$) {}
      if (Buffer.isBuffer(data)) {
        this$.emit('message', data, {
          address: peer_connection.remoteAddress,
          port: peer_connection.remotePort
        });
      }
    });
    x$.on('error', function(){
      debug('peer error: %o', arguments);
      this$.emit.apply(this$, ['error'].concat(slice$.call(arguments)));
    });
    x$.setMaxListeners(0);
    return x$;
  };
  /**
   * @param {string}	id
   * @param {string}	ip
   * @param {number}	port
   */
  x$.add_id_mapping = function(id, ip, port){
    var peer_connection, this$ = this;
    if (!this.peer_connections[ip + ":" + port]) {
      debug('bad peer specified for id mapping: %s => %o', id, {
        ip: ip,
        port: port
      });
      return;
    }
    peer_connection = this.peer_connections[ip + ":" + port];
    this.connections_id_mapping[id] = peer_connection;
    peer_connection.id = id;
    this.emit('node_connected', id);
    peer_connection.on('close', function(){
      this$.del_id_mapping(id);
    });
  };
  /**
   * @param {string} id
   *
   * @return {SimplePeer}
   */
  x$.get_id_mapping = function(id){
    return this.connections_id_mapping[id];
  };
  /**
   * @param {string} id
   */
  x$.del_id_mapping = function(id){
    var peer_connection;
    if (!this.connections_id_mapping[id]) {
      return;
    }
    peer_connection = this.connections_id_mapping[id];
    delete this.connections_id_mapping[id];
    if (!peer_connection.destroyed) {
      peer_connection.destroy();
    }
    this.emit('node_disconnected', id);
  };
  x$.known_ws_servers = function(){
    var peer_connection;
    return (function(){
      var ref$, results$ = [];
      for (peer_connection in ref$ = this.peer_connections) {
        peer_connection = ref$[peer_connection];
        results$.push(peer_connection.ws_server);
      }
      return results$;
    }.call(this)).filter(Boolean);
  };
  /**
   * @param {SimplePeer} peer_connection
   */
  x$.__register_connection = function(peer_connection){
    var this$ = this;
    this.peer_connections[peer_connection.remoteAddress + ":" + peer_connection.remotePort] = peer_connection;
    peer_connection.on('close', function(){
      delete this$.peer_connections[host + ":" + port];
    });
  };
  x$.__register_ws_connection_alias = function(webrtc_host, webrtc_port, websocket_host, websocket_port){
    var peer_connection, this$ = this;
    peer_connection = this.peer_connections[webrtc_host + ":" + webrtc_port];
    this.ws_connections_aliases[websocket_host + ":" + websocket_port] = peer_connection;
    peer_connection.on('close', function(){
      delete this$.ws_connections_aliases[websocket_host + ":" + websocket_port];
    });
  };
}).call(this);
